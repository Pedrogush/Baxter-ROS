#!/usr/bin/env python
import rospy
import ik_solver
import baxter_interface
import rosbag
from std_msgs.msg import Float64, String
import sensor_msgs.msg
from geometry_msgs.msg import (    
Point,
Quaternion,
)

def poseupdate_l(invert, var, x, y, z, loc, initialpose):
        if var==0:
            x = initialpose["position"].x+0.05*invert
        if var==1:
            y = initialpose["position"].y+0.05*invert
        if var==2:
            z = initialpose["position"].z+0.05*invert
        loc = Point(x,y,z)
        return loc

def poseupdate_a(invert, var, x, y, z, w, orient, initialpose):
        desiredpose = initialpose
        if var==0:
            x = initialpose["position"].x+0.05*invert
        if var==1:
            y = initialpose["position"].y+0.05*invert
        if var==2:
            z = initialpose["position"].z+0.05*invert
        orient = Quaternion(x1,y1,z1, w)
        return orient

def custom_right_moveto(limb_joints, invertcount, loc, orient, sequence, invert):
       right.move_to_joint_positions(limb_joints)
       invertcount = invertcount + 1
       sequence = sequence + 1
       invert = -invert
       if invertcount > 2:
          invertcount = 0 
 
# obj: move right arm to predetermined position, grip an object, move the end effector slightly in each direction and rotation, record effort on joints, guess weight and center of mass.
# movement is in meters 
sequence = 0
b = 0
invert = 1
invertcount = 0
rospy.init_node('move_right_hand')
EN = baxter_interface.RobotEnable()
EN.enable()
right = baxter_interface.Limb('right')
pose = right.endpoint_pose()
initialpose = pose
b = True
right.set_joint_position_speed(1)
desiredpose = initialpose
x = desiredpose["position"].x + 0.04*invert
y = desiredpose["position"].y
z = desiredpose["position"].z
x1 = desiredpose["orientation"].x
y1 = desiredpose["orientation"].y
z1 = desiredpose["orientation"].z
w = initialpose["orientation"].w
orient = Quaternion(x1, y1, z1, w)
loc = Point(x,y,z)
F = open('hand.feel', 'w')



#move along x for 2 centimeters from initial position in the positive direction, then reverses and goes 2 centimeters from initial position in the negative direction, same behavior is repeated for all linear coordinates 
while  (sequence < 3):
    limb_joints = ik_solver.ik_solve('right', poseupdate_l(invert, 0, x, y, z, loc, initialpose), orient)    
    custom_right_moveto(limb_joints, invertcount, loc, orient, sequence, invert) 
while  (2 < sequence < 6):
    limb_joints = ik_solver.ik_solve('right', poseupdate_l(invert, 1, x, y, z, loc, initialpose), orient)    
    custom_right_moveto(limb_joints, invertcount, loc, orient, sequence, invert)
while  (5 < sequence < 9):
    limb_joints = ik_solver.ik_solve('right', poseupdate_l(invert, 2, x, y, z, loc, initialpose), orient)    
    custom_right_moveto(limb_joints, invertcount, loc, orient, sequence, invert)    
while (8 < sequence < 12):
    limb_joints = ik_solver.ik_solve('right', loc, orient)    
    custom_right_moveto(limb_joints, invertcount, loc, poseupdate_a(invert, 0, x, y, z, w, orient, initialpose), sequence, invert)
while  (11 < sequence < 15):
    limb_joints = ik_solver.ik_solve('right', loc, orient)    
    custom_right_moveto(limb_joints, invertcount, loc, poseupdate_a(invert, 1, x, y, z, w, orient, initialpose), sequence, invert)
while  (14 < sequence < 18):
    limb_joints = ik_solver.ik_solve('right', loc, orient)    
    custom_right_moveto(limb_joints, invertcount, loc, poseupdate_a(invert, 2, x, y, z, w, orient, initialpose), sequence, invert)

#records /current command being executed/ along with timestamps, /a header/ and the effort variable from the topic. 

#/write current limb_joints in a text file name $Letter$$Direction$.txt/
#write output of /robot/JointStates and look for the effort variable
#write out the effort variable as a sequence of values for each joint
